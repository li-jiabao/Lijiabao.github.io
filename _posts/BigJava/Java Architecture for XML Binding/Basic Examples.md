
# Customizing JAXB Bindings

The following section describes several examples that build on the concepts demonstrated in the Basic examples.

The goal of this section is to illustrate how to customize JAXB bindings using custom binding declarations, made in one of the following two ways:

- As annotations made inline in an XML schema
- As statements in an external file passed to the JAXB binding 	compiler

Unlike the examples in 
[Basic JAXB Examples](basic.html), which focus on the Java code in the respective <tt>Main.java</tt> class files, the examples here focus on customizations made to the XML schema **before** generating the schema-derived Java binding classes.

This section introduces customizations that can be made to JAXB bindings and validation methods. For more information, see  
[JAXB Specification](http://jaxb.java.net).

## <a name="bnbbg" id="bnbbg">Why Customize?</a>

In most cases, the default bindings generated by the JAXB binding
compiler are sufficient. There are cases, however, in which you might want to modify the default bindings. Some of these include:

- Creating API documentation for the schema-derived JAXB packages, classes, methods and constants: By adding custom Javadoc tool annotations to your schemas, you can explain concepts, guidelines, and rules specific to your implementation.
<li>Providing semantically meaningful customized names for cases that the default XML name-to-Java identifier mapping cannot handle automatically; for example:
	<ul>
	- To resolve name collisions (as described in Appendix D.2.1 of the *JAXB Specification*). Note that the JAXB binding compiler detects and reports all name conflicts.
	- To provide names for typesafe enumeration constants that are not valid Java identifiers; for example, enumeration over integer values.
	- To provide better names for the Java representation of unnamed model groups when they are bound to a Java property or class.
	- To provide more meaningful package names than can be derived by default from the target namespace URI.
	
	- Specify that a model group must be bound to a class rather than 		a list.
	- Specify that a fixed attribute can be bound to a Java 		constant.
	- Override the specified default binding of XML Schema built-in 		data types to Java data types. In some cases, you might want to 	introduce an alternative Java class that can represent additional 		characteristics of the built-in XML Schema data type.
	
## <a name="bnbbh" id="bnbbh"></a>Customization Overview

This section explains some core JAXB customization concepts:

	- Inline and external customizations
	- Scope, inheritance, and precedence
	- Customization syntax
	- Customization namespace prefix

## <a name="bnbbi" id="bnbbi"></a>Inline and External Customizations

Customizations to the default JAXB bindings are made in the form of **binding declarations** passed to the JAXB binding compiler. These binding declarations can be made in either of two ways:

- As inline annotations in a source XML schema
- As declarations in an external binding customizations file

For some, using inline customizations is easier because you can see your customizations in the context of the schema to which they apply. Conversely, using an external binding customization file enables you to customize JAXB bindings without modifying the source schema, and enables you to easily apply customizations to several schema files at once.

Each of these types of customization is described in more detail in the following sections:

### <a name="bnbbj" id="bnbbj"></a>Inline Customizations

Customizations to JAXB bindings made by means of inline <b>binding
declarations</b> in an XML schema file take the form of <tt>&lt;xsd:appinfo&gt;</tt> elements embedded in schema  <tt>&lt;xsd:annotation&gt;</tt> elements (<tt>xsd:</tt> is the XML schema namespace prefix, as defined in W3C *XML Schema Part 1: Structures*). The general form for inline customizations is shown in the following example:

```

&lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
        &lt;!--
        ...
        binding declarations     .
        ...
        --&gt;
    &lt;/xs:appinfo&gt;
&lt;/xs:annotation&gt;

```


Customizations are applied at the location at which they are declared
in the schema. For example, a declaration at the level of a particular element applies to that element only. Note that the XML schema namespace prefix must be used with the <tt>&lt;annotation&gt;</tt> and <tt>&lt;appinfo&gt;</tt> declaration tags. In the previous example, <tt>xs:</tt> is used as the namespace prefix, so the declarations are tagged <tt>&lt;xs:annotation&gt;</tt> and <tt>&lt;xs:appinfo&gt;</tt>.

### <a name="bnbbk" id="bnbbk"></a>External Binding Customization Files

Customizations to JAXB bindings made by using an external file
containing binding declarations, take the general form shown in the following example:

```

&lt;jxb:bindings schemaLocation = "xs:anyURI"&gt;
    &lt;jxb:bindings node = "xs:string"&gt;*
        &lt;!-- binding declaration --&gt;
    &lt;jxb:bindings&gt;
&lt;/jxb:bindings&gt;

```

	- <tt>schemaLocation</tt> is a URI reference to the remote schema.
	- <tt>node</tt> is an XPath 1.0 expression that identifies the schema node within <tt>schemaLocation</tt> to which the given binding declaration is associated.

For example, the first <tt>schemaLocation</tt>/<tt>node</tt>
declaration in a JAXB binding declarations file specifies the schema
name and the root schema node:

```

&lt;jxb:bindings schemaLocation="po.xsd" node="/xs:schema"&gt;
&lt;/jxb:bindings&gt;

```

A subsequent <tt>schemaLocation</tt>/<tt>node</tt> declaration, such as  a <tt>simpleType</tt> element named <tt>ZipCodeType</tt> in the previous schema example, takes the following form:

```

&lt;jxb:bindings node="//xs:simpleType [@name=&#8217;ZipCodeType&#8217;]"&gt;

```

### <a name="bnbbl" id="bnbbl"></a>Binding Customization File Format

Binding customization files must be in ASCII text. The name or extension does not matter; although a typical extension, used in this chapter, is <tt>.xjb</tt>.

### <a name="bnbbm" id="bnbbm"></a>Passing Customization Files to the JAXB Binding Compiler

Customization files containing binding declarations are passed to
the JAXB Binding compiler, <tt>xjc</tt>, using the following syntax:

```

xjc -b file schema

```

 where *file* is the name of binding customization file, and
*schema* is the name of the schemas you want to pass to the binding compiler.

You can have a single binding file that contains customizations
for multiple schemas, or you can seperate the customizations into
multiple bindings files; for example:

```

xjc schema1.xsd schema2.xsd schema3.xsd \
    -b bindings123.xjb
xjc schema1.xsd schema2.xsd schema3.xsd \
    -b bindings1.xjb \
    -b bindings2.xjb \
    -b bindings3.xjb

```

Note that the ordering of schema files and binding files on the
command-line does not matter; although each binding customization file must be preceded by its own <tt>-b</tt> switch on the command line.

For more information about the <tt>xjc</tt> compiler options in general, see 
[JAXB Compiler Options](examples.html#bnbal).

### <a name="bnbbn" id="bnbbn"></a>Restrictions for External Binding Customizations

There are several rules that apply to binding declarations made in
an external binding customization file that do not apply to similar
declarations made inline in a source schema:

	<li>The binding customization file must begin with the
	<tt>jxb:bindings version</tt> attribute, plus attributes for the 		JAXB and XMLSchema namespaces:
<pre><code>
&lt;jxb:bindings version="1.0" 
    xmlns:jxb="http://java.sun.com/xml/ns/jaxb" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
</code></pre>
</li>
	<li>The remote schema to which the binding declaration applies
	must be identified explicitly in XPath notation by using a
	<tt>jxb:bindings</tt> declaration specifying 
	<tt>schemaLocation</tt> and <tt>node</tt> attributes:
	<ul>
	- <tt>schemaLocation</tt> specifies a URI reference to the remote 		schema.
	- <tt>node</tt> specifies an XPath 1.0 expression that identifies 		the schema node within <tt>schemaLocation</tt> to which the given 		binding declaration is associated; in the case of the initial 		<tt>jxb:bindings</tt> declaration in the binding customization 		file, this node is typically <tt>"/xs:schema"</tt>.
	
Similarly, individual nodes within the schema to which customizations are to be applied must be specified using XPath notation; for example:

```

&lt;jxb:bindings node="//xs:complexType [@name=&#8217;USAddress&#8217;]"&gt;

```

In such cases, the customization is applied to the node by the binding compiler as if the declaration was embedded inline in the node&#8217;s <tt>&lt;xs:appinfo&gt;</tt> element.

To summarize these rules, the external binding element
<tt>&lt;jxb:bindings&gt;</tt> is only recognized for processing by a JAXB binding compiler in three cases:

- When its parent is an <tt>&lt;xs:appinfo&gt;</tt> element.
- When it is an ancestor of another <tt>&lt;jxb:bindings&gt;</tt>	element.
- When it is the root element of a document. An XML document that has a <tt>&lt;jxb:bindings&gt;</tt> element as its root is referred to as an external binding declaration file.

### <a name="bnbbo" id="bnbbo"></a>Scope, Inheritance, and Precedence

Default JAXB bindings can be customized or overridden at four
different levels, or **scopes**.

The following figure illustrates the inheritance and precedence of customization declarations. Specifically, declarations towards the top of the pyramid inherit and supersede declarations below them.

Component declarations inherit from and supersede Definition declarations; Definition declarations inherit and supersede Schema declarations; and Schema declarations inherit and supersede Global declarations.

<a name="bnbbp" id="bnbbp"></a>Figure:&#160;Customization Scope Inheritance and Precedence

### Customization Syntax

The syntax for the four types of JAXB binding declarations, the syntax for the XML-to-Java data type binding declarations, and the customization namespace prefix are described in the following section.

   - [Global Binding Declarations](#bnbbr)
   - [Schema Binding Declarations](#bnbbs)
   - [Class Binding Declarations](#bnbbt)
   - [Property Binding Declarations](#bnbbu)
   - [javaType Binding Declarations](#bnbbv)
   - [Typesafe Enumeration Binding Declarations](#bnbbw)
   - [javadoc Binding Declarations](#bnbbx)

### <a name="bnbbr" id="bnbbr"></a>Global Binding Declarations

Global scope customizations are declared with <tt>&lt;globalBindings&gt;</tt>. The syntax for global scope customizations is as follows:

```

&lt;globalBindings&gt;
    [ collectionType = "collectionType" ]
    [ fixedAttributeAsConstantProperty = "true" | "false" | "1" | "0" ]
    [ generateIsSetMethod = "true" | "false" | "1" | "0" ]
    [ enableFailFastCheck = "true" | "false" | "1" | "0" ]
    [ choiceContentProperty = "true" | "false" | "1" | "0" ]
    [ underscoreBinding = "asWordSeparator" | "asCharInWord" ]
    [ typesafeEnumBase = "typesafeEnumBase" ]
    [ typesafeEnumMemberName = "generateName" | "generateError" ]
    [ enableJavaNamingConventions = "true" | "false" 
    | "1" | "0" ]
    [ bindingStyle = "elementBinding" | "modelGroupBinding" ]
    [ &lt;javaType&gt; ... &lt;/javaType&gt; ]*
&lt;/globalBindings&gt;

```

	<li><tt>collectionType</tt> can be either <tt>indexed</tt>
	or any fully qualified class name that implements		  		<tt>java.util.List</tt>.</li>
	<li><tt>fixedAttributeAsConstantProperty</tt> can
	be either <tt>true</tt>, <tt>false</tt>, <tt>1</tt>, or <tt>0</tt>. 		The default value is <tt>false</tt>.</li> 
	<li><tt>generateIsSetMethod</tt> can be either
	<tt>true</tt>, <tt>false</tt>, <tt>1</tt>,
	or <tt>0</tt>. The default value is <tt>false</tt>.</li>
	<li><tt>enableFailFastCheck</tt> can be either
	<tt>true</tt>, <tt>false</tt>, <tt>1</tt>,
	or <tt>0</tt>. If <tt>enableFailFastCheck</tt>
	is <tt>true</tt> or <tt>1</tt> and the JAXB implementation 		supports this optional checking, type constraint checking is 		performed when setting a property. The default value is 
	<tt>false</tt>. Please note that the JAXB implementation does not 		support failfast validation.</li>
	<li><tt>choiceContentProperty</tt> can be either <tt>true</tt>, 	<tt>false</tt>, <tt>1</tt>, or <tt>0</tt>. The default value is 	<tt>false</tt>. <tt>choiceContentProperty</tt> is not relevant when
	the <tt>bindingStyle</tt> is <tt>elementBinding</tt>.
	Therefore, if <tt>bindingStyle</tt> is specified as
	<tt>elementBinding</tt>, then the <tt>choiceContentProperty</tt> 		must result in an invalid customization.</li>
	<li><tt>underscoreBinding</tt> can be either
	<tt>asWordSeparator</tt> or <tt>asCharInWord</tt>.
	The default value is <tt>asWordSeparator</tt>.</li>
	<li><tt>typesafeEnumBase</tt> can be a list of
	QNames, each of which must resolve to a simple type definition. The
	default value is <tt>xs:NCName</tt>. See <a href="#bnbbw">Typesafe
	Enumeration Binding Declarations</a> for information about the 		localized mapping of <tt>simpleType</tt> definitions to Java
	<tt>typesafe enum</tt> classes.</li>
	<li><tt>typesafeEnumMemberName</tt> can be either
	<tt>generateError</tt> or <tt>generateName</tt>.
	The default value is <tt>generateError</tt>.</li>
	<li><tt>enableJavaNamingConventions</tt> can be either
	<tt>true</tt>, <tt>false</tt>, <tt>1</tt>, or <tt>0</tt>. The
	default value is <tt>true</tt>.</li>
	<li><tt>bindingStyle</tt> can be either
	<tt>elementBinding</tt>, or <tt>modelGroupBinding</tt>.
	The default value is <tt>elementBinding</tt>.</li>
	<li><tt>&lt;javaType&gt;</tt> can be zero or more javaType 		binding declarations. For more information, see
	[javaType Binding Declarations](#bnbbv).</li>

<tt>&lt;globalBindings&gt;</tt> declarations are only valid in the <tt>annotation</tt> element of the top-level <tt>schema</tt> element. There can only be a single instance of a <tt>&lt;globalBindings&gt;</tt>
declaration in any given schema or binding declarations file. If one
source schema includes or imports a second source schema, the  <tt>&lt;globalBindings&gt;</tt> declaration must be declared in the first source schema.

### <a name="bnbbs" id="bnbbs"></a>Schema Binding Declarations

Schema scope customizations are declared with <tt>&lt;schemaBindings&gt;</tt>. The syntax for schema scope customizations is:

```

&lt;schemaBindings&gt;
[ &lt;package&gt; package &lt;/package&gt; ]
[ &lt;nameXmlTransform&gt; ... &lt;/nameXmlTransform&gt; ]*
&lt;/schemaBindings&gt;
    
&lt;package 
    [ name = "packageName" ]
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/package&gt;

&lt;nameXmlTransform&gt;
[ &lt;typeName 
    [ suffix="suffix" ]
    [ prefix="prefix" ] /&gt; ]
[ &lt;elementName 
    [ suffix="suffix" ]
    [ prefix="prefix" ] /&gt; ]
[ &lt;modelGroupName 
    [ suffix="suffix" ]
    [ prefix="prefix" ] /&gt; ]
[ &lt;anonymousTypeName 
    [ suffix="suffix" ]
    [ prefix="prefix" ] /&gt; ]
&lt;/nameXmlTransform&gt;

```

As shown above, <tt>&lt;schemaBinding&gt;</tt> declarations include two subcomponents:

	<li><tt>&lt;package&gt;...&lt;/package&gt;</tt>
	specifies the name of the package and, if desired, the location of
	the API documentation for the schema-derived classes.</li>
	<li><tt>&lt;nameXmlTransform&gt;...&lt;/nameXmlTransform&gt;</tt>
	specifies customizations to be applied.</li>

### <a name="bnbbt" id="bnbbt"></a>Class Binding Declarations

The <tt>&lt;class&gt;</tt> binding declaration enables you to customize the binding of a schema element to a Java content interface or a Java <tt>Element</tt> interface. <tt>&lt;class&gt;</tt> declarations can be
used to customize:

- A name for a schema-derived Java interface
- An implementation class for a schema-derived Java content interface

The syntax for <tt>&lt;class&gt;</tt> customizations is:

```

&lt;class 
    [ name = "className"]
    [ implClass= "implClass" ] &gt;
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/class&gt;

```

	<li><tt>name</tt> is the name of the derived Java
	interface. It must be a valid Java interface name and must not
	contain a package prefix. The package prefix is inherited from the
	current value of the package.</li>
	- <tt>implClass</tt> is the name of the implementation class for 		*className* and must include the complete package name.
	- The <tt>&lt;javadoc&gt;</tt> element specifies the Javadoc tool 		annotations for the schema-derived Java interface. The string 		entered here must use <tt>CDATA</tt> or <tt>&lt;</tt> to escape 	embedded HTML tags.

### <a name="bnbbu" id="bnbbu"></a>Property Binding Declarations

The <tt>&lt;property&gt;</tt> binding declaration enables you to customize the binding of an XML schema element to its Java representation as a property. The scope of customization can either be at the definition level or component level depending upon where the <tt>&lt;property&gt;</tt> binding declaration is specified.

The syntax for <tt>&lt;property&gt;</tt> customizations is:

```

&lt;property
    [ name = "propertyName"]
    [ collectionType = "propertyCollectionType" ]
    [ fixedAttributeAsConstantProperty = "true" |
    "false" | "1" | "0" ]
    [ generateIsSetMethod = "true" | 
    "false" | "1" | "0" ]
    [ enableFailFastCheck ="true" | 
    "false" | "1" | "0" ]
    [ &lt;baseType&gt; ... &lt;/baseType&gt; ]
    [ &lt;javadoc&gt; ... &lt;/javadoc&gt; ]
&lt;/property&gt;

&lt;baseType&gt;
    &lt;javaType&gt; ... &lt;/javaType&gt;
&lt;/baseType&gt;

```

	<li><tt>name</tt> defines the customization value
	<tt>propertyName</tt>; it must be a valid Java identifier.</li>
	- <tt>collectionType</tt> defines the customization value 		<tt>propertyCollectionType</tt>, which is the collection type for 		the property, <tt>propertyCollectionType</tt>. If specified, the 		property can be either <tt>indexed</tt> or any fully-qualified 		class name that implements <tt>java.util.List</tt>.
	- <tt>fixedAttributeAsConstantProperty</tt> defines the 		customization value <tt>fixedAttributeAsConstantProperty</tt>. The 		value can be either <tt>true</tt>, <tt>false</tt>, <tt>1</tt>, or 		<tt>0</tt>.
	<li><tt>generateIsSetMethod</tt> defines the
	customization value of <tt>generateIsSetMethod</tt>.
	The value can be either <tt>true</tt>, <tt>false</tt>,
	<tt>1</tt>, or <tt>0</tt>.</li>
	<li><tt>enableFailFastCheck</tt> defines the
	customization value <tt>enableFailFastCheck</tt>.
	The value can be either <tt>true</tt>, <tt>false</tt>,
	<tt>1</tt>, or <tt>0</tt>. Please
	note that the JAXB implementation does not support failfast
	validation.</li>
	- <tt>&lt;javadoc&gt;</tt> customizes the Javadoc tool 		annotations for the property&#8217;s getter method. 

### <a name="bnbbv" id="bnbbv"></a>javaType Binding Declarations

The <tt>&lt;javaType&gt;</tt> declaration provides a way to customize the translation of XML data types to and from Java data types. XML provides more data types than Java, so the <tt>&lt;javaType&gt;</tt> declaration enables you to specify custom data type bindings when the default JAXB binding cannot sufficiently represent your schema.

The target Java data type can be a Java built-in data type or an
application-specific Java data type. If an application-specific Java data type is used as the target, your implementation must also provide parse and print methods for unmarshalling and marshalling data. To this end, the JAXB specification supports a <tt>parseMethod</tt> and <tt>printMethod</tt>:

- The <tt>parseMethod</tt> is called during unmarshalling to convert a string from the input document into a value of the target Java data type.
- The <tt>printMethod</tt> is called during marshalling to convert a value of the target type into a lexical representation.

If you prefer to define your own data type conversions, JAXB
defines a static class, <tt>DatatypeConverter</tt>, to assist in the parsing and printing of valid lexical representations of the XML Schema built-in data types.

The syntax for the <tt>&lt;javaType&gt;</tt> customization is:

```

&lt;javaType name= "*javaType*"
    [ xmlType= "*xmlType*" ]
    [ hasNsContext = "true" | "false" ]
    [ parseMethod= "*parseMethod*" ]
    [ printMethod= "*printMethod*" ]&gt;

```

	- <tt>name</tt> is the Java data type to which <tt>xmlType</tt> 		is to be bound.
	- <tt>xmlType</tt> is the name of the XML Schema data type to 	which <tt>javaType</tt> is to be bound; this attribute is required 		when the parent of the <tt>&lt;javaType&gt;</tt> declaration is   		<tt>&lt;globalBindings&gt;</tt>.
	<li><tt>hasNsContext</tt> allows a namespace context to be 		specified as a second parameter to a print or a parse method; 
	can be either <tt>true</tt>, <tt>false</tt>, <tt>1</tt>, or 
	<tt>0</tt>. By default, this attribute is <tt>false</tt>, and in 		most cases, there is no need to change it.</li>
	- <tt>parseMethod</tt> is the name of the parse method to be 		called during unmarshalling.
	- <tt>printMethod</tt> is the name of the print method to be 		called during marshalling.

The <tt>&lt;javaType&gt;</tt> declaration can be
used in:

	- A <tt>&lt;globalBindings&gt;</tt> declaration
	<li>An annotation element for simple type definitions,
	<tt>GlobalBindings</tt>, and <tt>&lt;basetype&gt;</tt>
	declarations</li>
	- A <tt>&lt;property&gt;</tt> declaration

See [<tt>MyDatatypeConverter</tt> Class](#bnbch) for an example of how <tt>&lt;javaType&gt;</tt> declarations and the <tt>DatatypeConverterInterface</tt> interface are implemented in a custom data type converter class.

### <a name="bnbbw" id="bnbbw"></a>Typesafe Enumeration Binding Declarations

The typesafe enumeration declarations provide a localized way to
map XML <tt>simpleType</tt> elements to Java <tt>typesafe enum</tt> classes. There are two types of typesafe enumeration declarations you can make:

- <tt>&lt;typesafeEnumClass&gt;</tt> lets you map an entire <tt>simpleType</tt> class to <tt>typesafe enum</tt> classes.
- <tt>&lt;typesafeEnumMember&gt;</tt> lets you map just selected members of a <tt>simpleType</tt> class to <tt>typesafe enum</tt> classes.

In both cases, there are two primary limitations on this type of
customization:

- Only <tt>simpleType</tt> definitions with enumeration facets can be customized using this binding declaration.
- This customization only applies to a single <tt>simpleType</tt> 	definition at a time. To map sets of similar <tt>simpleType</tt> 	definitions on a global level, use the <tt>typesafeEnumBase</tt> 	attribute in a <tt>&lt;globalBindings&gt;</tt> declaration, as described in [Global Binding Declarations](#bnbbr).

The syntax for the <tt>&lt;typesafeEnumClass&gt;</tt> customization is:


```

&lt;typesafeEnumClass 
    [ name = "enumClassName" ]
    [ &lt;typesafeEnumMember&gt; ... &lt;/typesafeEnumMember&gt; ]*
    [ &lt;javadoc&gt; enumClassJavadoc &lt;/javadoc&gt; ]
&lt;/typesafeEnumClass&gt;

```

	- <tt>name</tt> must be a valid Java Identifier, and must not 	have a package prefix.
	<li>You can have zero or more <tt>&lt;typesafeEnumMember&gt;</tt>
	declarations embedded in a <tt>&lt;typesafeEnumClass&gt;</tt>
	declaration.</li>
	- <tt>&lt;javadoc&gt;</tt> customizes the Javadoc tool 		annotations for the enumeration class.

The syntax for the <tt>&lt;typesafeEnumMember&gt;</tt>
customization is:

```

&lt;typesafeEnumMember 
    name = "enumMemberName"&gt;
    [ value = "enumMemberValue" ]
    [ &lt;javadoc&gt; enumMemberJavadoc &lt;/javadoc&gt; ]
&lt;/typesafeEnumMember&gt;

```

	- <tt>name</tt> must always be specified and must be a valid Java 		identifier.
	- <tt>value</tt> must be the enumeration value specified in the 		ource schema.
	- <tt>&lt;javadoc&gt;</tt> customizes the Javadoc tool 		annotations for the enumeration constant.

For inline annotations, the <tt>&lt;typesafeEnumClass&gt;</tt>
declaration must be specified in the annotation element of the
<tt>&lt;simpleType&gt;</tt> element. The <tt>&lt;typesafeEnumMember&gt;</tt> must be specified in the annotation element of the enumeration member. This enables the enumeration member to be customized independently from the
enumeration class.

For information about typesafe enum design patterns, see the
[sample chapter of Joshua Bloch&#8217;s *Effective Java Programming* on the Oracle Technology Network.](http://www.oracle.com/technetwork/java/page1-139488.html).

### <a name="bnbbx" id="bnbbx"></a>javadoc Binding Declarations

The <tt>&lt;javadoc&gt;</tt> declaration lets you add custom Javadoc tool annotations to schema-derived JAXB packages, classes, interfaces, methods, and fields. Note that <tt>&lt;javadoc&gt;</tt> declarations cannot be applied globally; they are only valid as sub-elements of other binding customizations.

The syntax for the <tt>&lt;javadoc&gt;</tt> customization is:

```

&lt;javadoc&gt;
    Contents in &lt;b&gt;Javadoc&lt;\b&gt; format.
&lt;/javadoc&gt;

```

or

```

&lt;javadoc&gt;
    &lt;&lt;![CDATA[Contents in &lt;b&gt;Javadoc&lt;\b&gt; format ]]&gt;
&lt;/javadoc&gt;

```

Note that documentation strings in <tt>&lt;javadoc&gt;</tt>
declarations applied at the package level must contain <tt>&lt;body&gt;</tt> open and close tags; for example:

```

&lt;jxb:package 
    name="primer.myPo"&gt;
    &lt;jxb:javadoc&gt;
        &lt;![CDATA[&lt;body&gt;
            Package level documentation for generated package primer.myPo.
        &lt;/body&gt;]]&gt;
    &lt;/jxb:javadoc&gt;
&lt;/jxb:package&gt;

```

### <a name="bnbby" id="bnbby"></a>Customization Namespace Prefix

All standard JAXB binding declarations must be preceded by a
namespace prefix that maps to the JAXB namespace URI 
[http://java.sun.com/xml/ns/jaxb](http://java.sun.com/xml/ns/jaxb). For example, in this sample, <tt>jxb:</tt> is used. To this end, any schema you want to customize with standard JAXB binding declarations **must** include the JAXB namespace declaration and JAXB version number at the top of the schema file. For example, in <tt>po.xsd</tt> for the Customize Inline example, the namespace declaration is as follows:

```

&lt;xsd:schema 
    xmlns:xsd= "http://www.w3.org/2001/XMLSchema"
    xmlns:jxb= "http://java.sun.com/xml/ns/jaxb"
    jxb:version="1.0"&gt;

```

A binding declaration with the <tt>jxb</tt> namespace prefix takes the following form:

```

&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
    &lt;jxb:globalBindings 
        *binding declarations* /&gt;
    &lt;jxb:schemaBindings&gt;
        ...
        *binding declarations*         .
        ...
    &lt;/jxb:schemaBindings&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;

```

Note that in this example, the <tt>globalBindings</tt> and  <tt>schemaBindings</tt> declarations are used to specify, respectively, global scope and schema scope customizations. These customization scopes are described in more detail in [Scope, Inheritance, and Precedence](#bnbbo).

#### <a name="bnbbz" id="bnbbz"></a>Customize Inline Example

The Customize Inline example illustrates some basic customizations made by means of inline annotations to an XML schema named <tt>po.xsd</tt>.
In addition, this example implements a custom data type converter class, <tt>MyDatatypeConverter.java</tt>, which illustrates print and parse methods in the <tt>&lt;javaType&gt;</tt> customization for handling custom data type conversions.

To summarize this example:

	<li><tt>po.xsd</tt> is an XML schema containing
	inline binding customizations.</li>
	<li><tt>MyDatatypeConverter.java</tt> is a Java
	class file that implements print and parse methods specified by
	<tt>&lt;javaType&gt;</tt> customizations in <tt>po.xsd</tt>.</li>
	<li><tt>Main.java</tt> is the primary class file
	in the Customize Inline example, which uses the schema-derived
	classes generated by the JAXB compiler.</li>

### <a name="bnbcb" id="bnbcb"></a>Building and Running the Customize Inline Example Using Ant

To compile and run the Customize Inline example using Ant, in a
terminal window, go to the 
*jaxb-ri-install*<tt>/samples/inline-customize/</tt>
directory and type the following:

```

ant 

```


Key customizations in this sample and the custom <tt>MyDatatypeConverter.java</tt> class are described in more detail in the following section.

### <a name="bnbcc" id="bnbcc"></a>Customized Schema

The customized schema used in the Customize Inline example is in
the file *jaxb-ri-install*<tt>/samples/inline-customize/po.xsd</tt>. The customizations are in the <tt>&lt;xsd:annotation&gt;</tt> tags.

### <a name="bnbcd" id="bnbcd"></a>Global Binding Declarations

The following code example shows the <tt>globalBindings</tt> declarations in <tt>po.xsd</tt>:

```

&lt;jxb:globalBindings
    fixedAttributeAsConstantProperty="true"
    collectionType="java.util.Vector"
    typesafeEnumBase="xsd:NCName"
    choiceContentProperty="false"
    typesafeEnumMemberName="generateError"
    bindingStyle="elementBinding"
    enableFailFastCheck="false"
    generateIsSetMethod="false"
    underscoreBinding="asCharInWord"/&gt;

```

In this example, all values are set to the defaults except for
<tt>collectionType</tt>.

	<li>Setting <tt>fixedAttributeAsConstantProperty</tt> to true
	indicates that all fixed attributes should be bound to Java 
	constants. By default, fixed attributes are mapped to either a
	simple or a collection property, whichever is more appropriate.</li>
	<li>Setting <tt>collectionType</tt> to <tt>java.util.Vector</tt>
        specifies that all lists in the generated implementation classes  		are represented internally as vectors. Note that the class name you 		specify for <tt>collectionType</tt> must implement 
	<tt>java.util.List</tt> and be callable by <tt>newInstance</tt>. 	 </li>
	<li>If <tt>typesafeEnumBase</tt> is set to <tt>xsd:string</tt>, it 		is a global way to specify that all <tt>simple</tt> type 		definitions derived directly or indirectly from <tt>xsd:string</tt>
	and having enumeration facets, must be bound by default to a
	<tt>typesafe enum</tt>. If <tt>typesafeEnumBase</tt> is set to an 		empty string (<tt>""</tt>), no <tt>simple</tt> type 		definitions are bound to a <tt>typesafe enum</tt> class by default. 		The value of <tt>typesafeEnumBase</tt> can be any atomic simple 	type definition except <tt>xsd:boolean</tt> and both binary types.
	</li>
	<li>The JAXB implementation does not support the
	<tt>enableFailFastCheck</tt> attribute.
	
<hr />**Note:**&#160;Using typesafe enum classes enables you to map schema enumeration values to Java constants, which makes it possible to do comparisons on Java constants rather than on string values.
<hr />
</li>

### <a name="bnbce" id="bnbce"></a>Schema Binding Declarations

The following code shows the schema binding declarations in
<tt>po.xsd</tt>:

```

&lt;jxb:schemaBindings&gt;
&lt;jxb:package name="primer.myPo"&gt;
    &lt;jxb:javadoc&gt;
        &lt;![CDATA[&lt;body&gt;
            Package level documentation for generated package primer.myPo.
        &lt;/body&gt;]]&gt;
    &lt;/jxb:javadoc&gt;
&lt;/jxb:package&gt;
    &lt;jxb:nameXmlTransform&gt;
        &lt;jxb:elementName suffix="Element"/&gt;
    &lt;/jxb:nameXmlTransform&gt;
&lt;/jxb:schemaBindings&gt;

```

	<li><tt>&lt;jxb:package name="primer.myPo"/&gt;</tt>
	specifies the <tt>primer.myPo</tt> as the package in which the 		schema-derived classes are generated.</li>
	<li><tt>&lt;jxb:nameXmlTransform&gt;</tt>
	specifies that all generated Java element interfaces have
	<tt>Element</tt> appended to the generated names by default. 
	For example, when the JAXB compiler is run against this schema, 
	the element interfaces <tt>CommentElement</tt> 	and
	<tt>PurchaseOrderElement</tt> are generated. By contrast, without 		this customization, the default binding generates <tt>Comment</tt> 		and <tt>PurchaseOrder</tt>.
	This customization is useful if a schema uses the same name in
	different symbol spaces; for example, in the global element and 
	type definitions. In such cases, this customization enables you to
	resolve the collision with one declaration rather than having to
	individually resolve each collision with a separate binding
	declaration.</li>
	<li><tt>&lt;jxb:javadoc&gt;</tt> specifies
	customized Javadoc tool annotations for the <tt>primer.myPo</tt>
	package. Note that, unlike the <tt>&lt;javadoc&gt;</tt>
	declarations at the class level, as shown in the following example, 		the opening and closing <tt>&lt;body&gt;</tt> tags must be included 		when the <tt>&lt;javadoc&gt;</tt> declaration is made at the
	package level.</li>

### <a name="bnbcf" id="bnbcf"></a>Class Binding Declarations

The following code shows the class binding declarations in <tt>po.xsd</tt>:

```

&lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:annotation&gt;
        &lt;xsd:appinfo&gt;
            &lt;jxb:class name="POType"&gt;
                &lt;jxb:javadoc&gt;
                    A &amp;lt;b&gt;Purchase Order&amp;lt;/b&gt;
                    consists of addresses and items.
                &lt;/jxb:javadoc&gt;
            &lt;/jxb:class&gt;
        &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;!-- ... --&gt;
&lt;/xsd:complexType&gt;

```


The Javadoc tool annotations for the schema-derived <tt>POType</tt>
class will contain the description <tt>"A
&amp;lt;b&gt;Purchase Order&amp;lt;/b&gt; consists of addresses and
items."</tt> The <tt>&amp;lt;</tt> is used to escape the opening bracket on the <tt>&lt;b&gt;</tt> HTML tags.

Later in <tt>po.xsd</tt>, another <tt>&lt;javadoc&gt;</tt>
customization is declared at this class level, but this time the HTML
string is escaped with <tt>CDATA</tt>:

```

&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
        &lt;jxb:class&gt;
            &lt;jxb:javadoc&gt;
                &lt;![CDATA[
                    First line of documentation for a
                    &lt;b&gt;USAddress&lt;/b&gt;.]]&gt;
            &lt;/jxb:javadoc&gt;
        &lt;/jxb:class&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;

```

### <a name="bnbcg" id="bnbcg"></a>Property Binding Declarations

Of particular interest here is the <tt>generateIsSetMethod</tt>
customization, which causes two additional property methods,
<tt>isSetQuantity</tt> and <tt>unsetQuantity</tt>, to be generated. These methods enable a client application to distinguish between schema default values and values occurring explicitly within an instance document.

For example, in <tt>po.xsd</tt>:

```

&lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
        &lt;xsd:element name="item" 
            minOccurs="1"  
            maxOccurs="unbounded"&gt;
            &lt;xsd:complexType&gt;
                &lt;xsd:sequence&gt;
                    &lt;xsd:element 
                        name="productName" 
                        type="xsd:string"/&gt;
                    &lt;xsd:element 
                        name="quantity" 
                        default="10"&gt;
                        &lt;xsd:annotation&gt;
                            &lt;xsd:appinfo&gt;
                                &lt;jxb:property 
                                    generateIsSetMethod="true"/&gt;
                            &lt;/xsd:appinfo&gt;
                        &lt;/xsd:annotation&gt;
                        &lt;!-- ... --&gt;
                    &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;

```

The <tt>@generateIsSetMethod</tt> applies to the <tt>quantity</tt> element, which is bound to a property within the <tt>Items.ItemType</tt> interface. <tt>unsetQuantity</tt> and <tt>isSetQuantity</tt> methods are generated in the <tt>Items.ItemType</tt> interface.

### <a name="bnbch" id="bnbch"></a><tt>MyDatatypeConverter</tt> Class

The class *jaxb-ri-install*<tt>/samples/inline-customize/src/inlinecustomize/primer/MyDatatypeConverter</tt>, shown in the following example, provides a way to customize the translation of XML data types to and from Java data types using a <tt>&lt;javaType&gt;</tt> customization.


```

package primer;
import java.math.BigInteger;
import javax.xml.bind.DatatypeConverter;

public class MyDatatypeConverter {

    public static short parseIntegerToShort(String value) {
        BigInteger result = DatatypeConverter.parseInteger(value);
        return (short)(result.intValue());
    }

    public static String printShortToInteger(short value) {
        BigInteger result = BigInteger.valueOf(value);
        return DatatypeConverter.printInteger(result);
    }

    public static int parseIntegerToInt(String value) {
        BigInteger result = DatatypeConverter.parseInteger(value);
        return result.intValue();
    }

    public static String printIntToInteger(int value) {
        BigInteger result = BigInteger.valueOf(value);
        return DatatypeConverter.printInteger(result);
    }
};

```

The following code shows how the <tt>MyDatatypeConverter</tt>
class is referenced in a <tt>&lt;javaType&gt;</tt> declaration in <tt>po.xsd</tt>:

```

&lt;xsd:simpleType name="ZipCodeType"&gt;
**&lt;xsd:annotation&gt;**
    **&lt;xsd:appinfo&gt;**
    **&lt;jxb:javaType name="int"**
        **parseMethod="primer.MyDatatypeConverter.parseIntegerToInt"**
        **printMethod="primer.MyDatatypeConverter.printIntTo Integer" /&gt;**
    **&lt;/xsd:appinfo&gt;**
**&lt;/xsd:annotation&gt;**
    &lt;xsd:restriction base="xsd:integer"&gt;
    &lt;xsd:minInclusive value="10000"/&gt;
    &lt;xsd:maxInclusive value="99999"/&gt;
    &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;

```

In this example, the <tt>jxb:javaType</tt> binding declaration overrides the default JAXB binding of this type to <tt>java.math.BigInteger</tt>. For the purposes of the Customize Inline example, the restrictions on <tt>ZipCodeType</tt> (specifically, that valid United States ZIP codes are limited to five digits) make it possible that all valid values can fit within the Java primitive data type <tt>int</tt>. Note also that, because <tt>&lt;jxb:javaType name="int"/&gt;</tt> is declared within <tt>ZipCodeType</tt>, the customization applies to all JAXB properties that reference this <tt>simpleType</tt> definition, including the <tt>getZip</tt> and <tt>setZip</tt> methods.

#### <a name="bnbci" id="bnbci"></a>DataType Converter Example

The DataType Converter example is similar to the Customize Inline example. As with the Customize Inline example, the customizations in the Datatype Converter example are made by using inline binding declarations in the XML schema for the application, <tt>po.xsd</tt>.

The global, schema, and package, and most of the class customizations for the Customize Inline and DataType Converter examples are identical. Where the Datatype Converter example differs from the Customize Inline example is in the <tt>parseMethod</tt> and <tt>printMethod</tt> used for converting XML data to the Java <tt>int</tt> data type.

Specifically, rather than using methods in the custom <tt>MyDataTypeConverter</tt> class to perform these data type conversions, the Datatype Converter example uses the built-in methods provided by <tt>javax.xml.bind.DatatypeConverter</tt>:

```

&lt;xsd:simpleType name="ZipCodeType"&gt;
    &lt;xsd:annotation&gt;
        &lt;xsd:appinfo&gt;
            &lt;jxb:javaType 
                name="int"
                parseMethod="javax.xml.bind.DatatypeConverter.parseInt"
                printMethod="javax.xml.bind.DatatypeConverter.printInt"/&gt;
        &lt;/xsd:appinfo&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:restriction base="xsd:integer"&gt;
        &lt;xsd:minInclusive value="10000"/&gt;
        &lt;xsd:maxInclusive value="99999"/&gt;
    &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;

```

### <a name="bnbck" id="bnbck"></a>Building and Running the Datatype Converter Example Using Ant

To compile and run the DataType Converter example using Ant, in a
terminal window, go to the *jaxb-ri-install*<tt>/samples/datatypeconverter/</tt> directory and type the following:

```

ant

```

#### <a name="bnbcl" id="bnbcl"></a>Binding Declaration Files

The following sections provide information about binding declaration files:

<li>[JAXB Version, Namespace, and Schema Attributes](#bnbcm)
</li>
- [Global and Schema Binding Declarations](#bnbcq)
- [Class Declarations](#bnbcr)

### <a name="bnbcm" id="bnbcm"></a>JAXB Version, Namespace, and Schema Attributes

All JAXB binding declaration files must begin with:

	- JAXB version number
	- Namespace declarations
	- Schema name and node

The version, namespace, and schema declarations in <tt>bindings.xjb</tt>
are as follows:

```

&lt;jxb:bindings 
    version="1.0"
    xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;jxb:bindings 
        schemaLocation="po.xsd" 
        node="/xs:schema"&gt;
            &lt;!-- ...
            *binding-declarations* 
            ... --&gt;
    &lt;/jxb:bindings&gt;
    &lt;!-- 
    schemaLocation="po.xsd" 
    node="/xs:schema" --&gt;
&lt;/jxb:bindings&gt;

```

### <a name="bnbcn" id="bnbcn"></a>JAXB Version Number

An XML file with a root element of <tt>&lt;jaxb:bindings&gt;</tt>
is considered an external binding file. The root element must specify
the JAXB version attribute with which its binding declarations must
comply; specifically the root <tt>&lt;jxb:bindings&gt;</tt> element must contain either a &lt;<tt>jxb:version&gt;</tt> declaration or a <tt>version</tt> attribute. By contrast, when making binding declarations inline, the JAXB version number is made as an attribute of the <tt>&lt;xsd:schema&gt;</tt> declaration:

```

&lt;xsd:schema 
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
    jxb:version="1.0"&gt;

```

### <a name="bnbco" id="bnbco"></a>Namespace Declarations

As shown in <a href="#bnbcm">JAXB Version, Namespace, and Schema
Attributes</a>, the namespace declarations in the external binding
declarations file include both the JAXB namespace and the XMLSchema
namespace. Note that the prefixes used in this example could in fact
be anything you want; the important thing is to consistently use
whatever prefixes you define here in subsequent declarations in the
file.

### <a name="bnbcp" id="bnbcp"></a>Schema Name and Schema Node

The fourth line of the code in [JAXB Version, Namespace, and Schema Attributes](#bnbcm) specifies the name of the schema to which this binding declarations file applies, and the schema node at which the customizations will first take effect. Subsequent binding declarations in this file can reference specific nodes within the schema, but this first declaration should encompass the schema as a whole; for example, in <tt>bindings.xjb</tt>:

```

&lt;jxb:bindings schemaLocation="po.xsd" node="/xs:schema"&gt;

```

### <a name="bnbcq" id="bnbcq"></a>Global and Schema Binding Declarations

The global schema binding declarations in <tt>bindings.xjb</tt>
are the same as those in <tt>po.xsd</tt> for the DataType Converter example. The only difference is that because the declarations in <tt>po.xsd</tt> are made inline, you must embed them in <tt>&lt;xs:appinfo&gt;</tt> elements, which are in turn embedded in <tt>&lt;xs:annotation&gt;</tt> elements. Embedding declarations in this way is unnecessary in the external bindings file.

```

&lt;jxb:globalBindings
    fixedAttributeAsConstantProperty="true"
    collectionType="java.util.Vector"
    typesafeEnumBase="xs:NCName"
    choiceContentProperty="false"
    typesafeEnumMemberName="generateError"
    bindingStyle="elementBinding"
    enableFailFastCheck="false"
    generateIsSetMethod="false"
    underscoreBinding="asCharInWord"/&gt;
    &lt;jxb:schemaBindings&gt;
        &lt;jxb:package name="primer.myPo"&gt;
            &lt;jxb:javadoc&gt;
                &lt;![CDATA[&lt;body&gt;
                    Package level documentation for generated package
                    primer.myPo.&lt;/body&gt;]]&gt;
                &lt;/jxb:javadoc&gt;
        &lt;/jxb:package&gt;
        &lt;jxb:nameXmlTransform&gt;
            &lt;jxb:elementName suffix="Element"/&gt;
        &lt;/jxb:nameXmlTransform&gt;
    &lt;/jxb:schemaBindings&gt;

```


By comparison, the syntax used in <tt>po.xsd</tt> for the DataType Converter example is:

```

&lt;xsd:annotation&gt;
    &lt;xsd:appinfo&gt;
        &lt;jxb:globalBindings
            ...
            *binding-declarations*
            ...
        &lt;jxb:schemaBindings&gt;
            ...
            *binding-declarations*
            ...
        &lt;/jxb:schemaBindings&gt;
    &lt;/xsd:appinfo&gt;
&lt;/xsd:annotation&gt;

```

### <a name="bnbcr" id="bnbcr"></a>Class Declarations

The class-level binding declarations in <tt>bindings.xjb</tt>
differ from the analogous declarations in <tt>po.xsd</tt> for the Datatype Converter example in two ways:

- As with all other binding declarations in <tt>bindings.xjb</tt>, you do not need to embed your customizations in schema  <tt>&lt;xsd:appinfo&gt;</tt> elements.
<li>You must specify the schema node to which the customization is applied. The general syntax for this type of declaration is:
<pre><code>
&lt;jxb:bindings node="//*node-type*[@name=&#8217;*node-name*&#8217;]"&gt;
</code></pre>
</li>

For example, the following code shows binding declarations for the
<tt>complexType</tt> named <tt>USAddress</tt>.

```

&lt;jxb:bindings node="//xs:complexType [@name=&#8217;USAddress&#8217;]"&gt;
    &lt;jxb:class&gt;
        &lt;jxb:javadoc&gt;
            &lt;![CDATA[
                First line of documentation for a &lt;b&gt;USAddress&lt;/b&gt;.
            ]]&gt;
        &lt;/jxb:javadoc&gt;
    &lt;/jxb:class&gt;

&lt;jxb:bindings node=".//xs:element [@name=&#8217;name&#8217;]"&gt;
    &lt;jxb:property name="toName"/&gt;
&lt;/jxb:bindings&gt;

&lt;jxb:bindings node=".//xs:element [@name=&#8217;zip&#8217;]"&gt;
    &lt;jxb:property name="zipCode"/&gt;
&lt;/jxb:bindings&gt;
&lt;/jxb:bindings&gt;
&lt;!-- 
    node="//xs:complexType
    [@name=&#8217;USAddress&#8217;]" --&gt;

```

Note in this example that <tt>USAddress</tt> is the parent of the child elements <tt>name</tt> and <tt>zip</tt>, and therefore a 
<tt>&lt;/jxb:bindings&gt;</tt> tag encloses the <tt>bindings</tt> declarations for the child elements and the class-level <tt>javadoc</tt> declaration.

#### <a name="bnbcs" id="bnbcs"></a>External Customize Example

The External Customize example is identical to the DataType Converter example, except that the binding declarations in the External Customize example are made by using an external binding declarations file rather than inline in the source XML schema.

The binding customization file used in the External Customize
example is *jaxb-ri-install*<tt>/samples/external-customize/binding.xjb</tt>.

This section compares the customization declarations in <tt>bindings.xjb</tt> with the analogous declarations used in the XML schema, <tt>po.xsd</tt>, in the DataType Converter example. The two sets of declarations achieve precisely the same results.

### <a name="bnbcu" id="bnbcu"></a>Building and Running the External Customize Example Using Ant

To compile and run the External Customize example using Ant, in a
terminal window, go to the *jaxb-ri-install*<tt>/samples/external-customize/</tt> directory and type the following:

```

ant

```
