
# Effects of Type Erasure and Bridge Methods


Sometimes type erasure causes a situation that you may not have anticipated. The following example shows how this can occur. The example (described in
[Bridge Methods](#bridgeMethods)) shows how a compiler sometimes creates a synthetic method, called a bridge method, as part of the type erasure process.


Given the following two classes:

```

public class Node&lt;T&gt; {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node&lt;Integer&gt; {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

```


Consider the following code:

```

MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     
Integer x = mn.data;    // Causes a ClassCastException to be thrown.

```


After type erasure, this code becomes:

```

MyNode mn = new MyNode(5);
Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
n.setData("Hello");
Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.

```


Here is what happens as the code is executed:

- <tt>n.setData("Hello");</tt> causes the method <tt>setData(Object)</tt> to be executed on the object of class <tt>MyNode</tt>. (The <tt>MyNode</tt> class inherited <tt>setData(Object)</tt> from <tt>Node</tt>.)
- In the body of <tt>setData(Object)</tt>, the data field of the object referenced by <tt>n</tt> is assigned to a <tt>String</tt>.
- The data field of that same object, referenced via <tt>mn</tt>, can be accessed and is expected to be an integer (since <tt>mn</tt> is a <tt>MyNode</tt> which is a <tt>Node&lt;Integer&gt;</tt>.
- Trying to assign a <tt>String</tt> to an <tt>Integer</tt> causes a <tt>ClassCastException</tt> from a cast inserted at the assignment by a Java compiler.

## <a name="bridgeMethods" id="bridgeMethods">Bridge Methods</a>


When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a **bridge method**, as part of the type erasure process. You normally don't need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.


After type erasure, the <tt>Node</tt> and <tt>MyNode</tt> classes become:

```

public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

```


After type erasure, the method signatures do not match. The <tt>Node</tt> method becomes <tt>setData(Object)</tt> and the <tt>MyNode</tt> method becomes <tt>setData(Integer)</tt>. Therefore, the <tt>MyNode</tt> <tt>setData</tt> method does not override the <tt>Node</tt> <tt>setData</tt> method.


To solve this problem and preserve the
[polymorphism](../IandI/polymorphism.html) of generic types after type erasure, a Java compiler generates a bridge method to ensure that subtyping works as expected. For the <tt>MyNode</tt> class, the compiler generates the following bridge method for <tt>setData</tt>:

```

class MyNode extends Node {

    <strong>// Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }</strong>

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}

```


As you can see, the bridge method, which has the same method signature as the <tt>Node</tt> class's <tt>setData</tt> method after type erasure, delegates to the original <tt>setData</tt> method.
